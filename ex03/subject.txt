Interfaces don’t exist in C++98 (not even in C++20). However, pure abstract classes
are commonly called interfaces. Thus, in this last exercise, 
let’s try to implement interfaces in order to make sure you got this module.
Complete the definition of the following AMateria class and implement the necessary member functions.

C++98에서 (심지어 C++20에서도) 인터페이스는 존재하지 않습니다. 
그러나 순수 추상 클래스는 일반적으로 인터페이스라고 불립니다. 
그러므로, 이 마지막 연습에서는 이 모듈을 이해했는지 확인하기 위해 인터페이스를 구현해 보겠습니다.
다음 AMateria 클래스의 정의를 완성하고 필요한 멤버 함수를 구현하세요.

class AMateria
{
protected:
[...]
public:
AMateria(std::string const & type);
[...]
std::string const & getType() const; //Returns the materia type
virtual AMateria* clone() const = 0;
virtual void use(ICharacter& target);
};

Implement the Materias concrete classes Ice and Cure. 
Use their name in lowercase ("ice" for Ice, "cure" for Cure) to set their types. 
Of course, their member function
clone() will return a new instance of the same type (i.e., if you clone an Ice Materia,
you will get a new Ice Materia).

Ice와 Cure라는 Materias 구체 클래스를 구현하세요. 
그들의 타입을 설정하기 위해 이름을 소문자("ice"는 Ice용, "cure"는 Cure용)로 사용하세요. 
물론, 그들의 멤버 함수 clone()은 같은 타입의 새 인스턴스를 반환할 것입니다
(즉, Ice Materia를 복제하면 새로운 Ice Materia를 얻게 됩니다).


The use(ICharacter&) member function will display:
• Ice: "* shoots an ice bolt at <name> *"
• Cure: "* heals <name>’s wounds *"
<name> is the name of the Character passed as parameter. Don’t print the angle
brackets (< and >).
While assigning a Materia to another, copying the type doesn’t make
sense.
Write the concrete class Character which will implement the following interface:

use(ICharacter&) 멤버 함수는 다음을 표시할 것입니다:

Ice: "* shoots an ice bolt at <name> *"
Cure: "* heals <name>’s wounds *"
<name>은 매개변수로 전달된 Character의 이름입니다. 꺾쇠괄호(<와 >)는 출력하지 마세요.

Materia를 다른 것에 할당할 때, 타입을 복사하는 것은 의미가 없습니다.

다음 인터페이스를 구현할 구체 클래스 Character를 작성하세요:

class ICharacter
{
public:
virtual ~ICharacter() {}
virtual std::string const & getName() const = 0;
virtual void equip(AMateria* m) = 0;
virtual void unequip(int idx) = 0;
virtual void use(int idx, ICharacter& target) = 0;
};


The Character possesses an inventory of 4 slots, which means 4 Materias at most.
The inventory is empty at construction. They equip the Materias in the first empty slot
they find. This means, in this order: from slot 0 to slot 3. In case they try to add
a Materia to a full inventory, or use/unequip an unexisting Materia, don’t do anything
(but still, bugs are forbidden). The unequip() member function must NOT delete the
Materia!


캐릭터는 4개의 슬롯을 가진 인벤토리를 소유하고 있으며, 이는 최대 4개의 마테리아를 의미합니다. 
인벤토리는 생성 시 비어 있습니다. 그들은 발견한 첫 번째 빈 슬롯에 마테리아를 장착합니다.
 이는 이 순서대로입니다: 슬롯 0부터 슬롯 3까지. 
 만약 인벤토리가 가득 찼거나 존재하지 않는 마테리아를 추가하거나 사용/해제하려고 시도하는 경우, 
 아무 것도 하지 않아야 합니다(그러나 여전히 버그는 금지됩니다). 
 unequip() 멤버 함수는 마테리아를 삭제해서는 안 됩니다!

Handle the Materias your character left on the floor as you like.
Save the addresses before calling unequip(), or anything else, but
don’t forget that you have to avoid memory leaks.
The use(int, ICharacter&) member function will have to use the Materia at the
slot[idx], and pass the target parameter to the AMateria::use function.
 
캐릭터가 바닥에 남긴 마테리아를 자유롭게 처리하세요.
unequip()을 호출하기 전이나, 다른 것을 하기 전에 주소를 저장하세요, 하지만 메모리 누수를 피하는 것을 잊지 마세요.
use(int, ICharacter&) 멤버 함수는 slot[idx]의 마테리아를 사용해야 하며, 대상 매개변수를 AMateria::use 함수에 전달해야 합니다.


Your character’s inventory will be able to support any type of
AMateria.
Your Character must have a constructor taking its name as a parameter. Any copy
(using copy constructor or copy assignment operator) of a Character must be deep.
During copy, the Materias of a Character must be deleted before the new ones are added
to their inventory. Of course, the Materias must be deleted when a Character is destroyed.
Write the concrete class MateriaSource which will implement the following interface:

캐릭터의 인벤토리는 어떤 타입의 AMateria도 지원할 수 있을 것입니다.
캐릭터는 이름을 매개변수로 받는 생성자를 가져야 합니다. 캐릭터의 복사(복사 생성자 또는 복사 할당 연산자 사용)는 깊은 복사가 되어야 합니다.
복사하는 동안, 캐릭터의 마테리아는 새로운 것이 인벤토리에 추가되기 전에 삭제되어야 합니다. 
물론, 캐릭터가 파괴될 때 마테리아는 삭제되어야 합니다.
다음 인터페이스를 구현할 구체 클래스 MateriaSource를 작성하세요:

class IMateriaSource
{
public:
virtual ~IMateriaSource() {}
virtual void learnMateria(AMateria*) = 0;
virtual AMateria* createMateria(std::string const & type) = 0;
};
• learnMateria(AMateria*)
Copies the Materia passed as a parameter and store it in memory so it can be cloned
later. Like the Character, the MateriaSource can know at most 4 Materias. They
are not necessarily unique.
• createMateria(std::string const &)

Returns a new Materia. The latter is a copy of the Materia previously learned by
the MateriaSource whose type equals the one passed as parameter. Returns 0 if
the type is unknown.
In a nutshell, your MateriaSource must be able to learn "templates" of Materias to
create them when needed. Then, you will be able to generate a new Materia using just
a string that identifies its type.


===========================================================================================

learnMateria(AMateria*)
매개변수로 전달된 마테리아를 복사하여 메모리에 저장해 나중에 복제할 수 있도록 합니다. 
캐릭터와 마찬가지로, 마테리아 소스는 최대 4개의 마테리아를 알 수 있습니다. 
그들이 반드시 고유할 필요는 없습니다.

createMateria(std::string const &)
새로운 마테리아를 반환합니다. 후자는 마테리아 소스에 의해 이전에 배워진 마테리아의 복사본으로, 
그 타입이 매개변수로 전달된 타입과 동일합니다. 타입이 알려지지 않은 경우 0을 반환합니다.
간단히 말해서, 마테리아 소스는 필요할 때 생성할 수 있는 마테리아의 "템플릿"을 배울 수 있어야 합니다. 
그러면 그 타입을 식별하는 문자열만 사용하여 새로운 마테리아를 생성할 수 있습니다.








